= Functional Programming: Go vs. Elixir
by Lukas Buchner
v1.0, 2018-23-12
:source-highlighter: rouge
:highlightjsdir: highlight
:stem:

== Introduction
During the last decades the functional programming paradigm has become a lot more popular and respectable. 
Thus language designers tend to incorporate functional features into their programming languages. 
In this paper I try to shed some light on how the programming languages Golang and Elixir approach functional programming. 
For the sake of completeness, the considered versions of the languages are golang 1.11.4 and elixir 1.7.4. +

TODO: Maybe Add definition of functional programming
TODO: Little introduction to Go
TODO: Little Introduction to Elixir

== Lambda Calculus
A myriad of buzzwords, mathematical ideas and seemingly necessary features revolve around functional programming. 
However the essence of these languages is way simpler. 
Apparently almost all functional languages share a common ancestor, the lambda calculus. 
Introduced as computational model by the mathematician Alonzo Church in the 1930s, it does not dictate any of the modern languages' features as necessity. 
In fact its ruleset could barely be simpler. 
The Lambda Calculus allows to define functions, apply them and then compute them (obivously the idea is a little more complex than that, but no deeper knowledge is needed for understanding this paper, thus the simplification). Let's have a look at how the languages handle these scenarios:

.main.go
[source, go]
----

func world() string { // <1>
	return "World!"
}

func hello(x func() string) { <2>
	fmt.Printf("Hello %v", x())
}

hello(world) // <3>

----

<1> Defines a function in Go
<2> Defines a function that takes another function as parameter. The lambda calculus allows this implicitly and Go can do this too
<3> Applies a function and computes the result

.main.exs
[source, elixir]
----

defmodule Greeter do
  def world(), do: "World!" //<1>
  def hello(x), do: IO.puts "Hello " <> x.() //<2>
end

IO.puts Greeter.hello(&Greeter.world/0) //<3>

----

<1> Defines a function in Elixir
<2> Defines a function, which takes a function as parameter. 
<3> Applies a function and computes the result. The *&* is used to pass a function defined in a module as a parameter whereas the */* denotes its arity. In this case the function *world* is of arity 0 as it does not take any parameters.

Both languages provide toolkits allowing the same things as the lambda calculus and as such can compute anything computable by it. 
So in theory we could end here agreeing that both languages on a low level basis provide everything needed for functional programming. 
However for a programming language to be practical for humans a lot more needs to be taken into consideration.

== Type Systems

Go is a compiled language with a static type system. Thus all types of a program are known at compile time. In case types are not compatible the compiler will gladly let you know:

[source, go]
----

func isTrue(b bool) bool {
	return b
}

isTrue(10) //<1>
----

<1> compiler says: cannot use 10 (type int) as type bool in argument to isTrue

For primitive values Go does its job. How about writing a function, that always returns the passed parameter, known as the Id function. That should be easy, right?

[source, go]
----
func id(x interface{}) interface{} { //<1>
	return x
}

fmt.Print(  id(10).(int)  ) //<2>
fmt.Print(  id(true).(int)  ) //<3>
----
<1> Go lacks support for parametric polymorphism. To be generic, one has to use the empty interface{}, which may contain anything.
<2> Calls *id* with an integer. Returns the interface{} and has to be casted to an integer. 
<3> Compiles without errors, but raises a panic at runtime as the cast cannot be performed. 

Already it is a hassle working with the interface{}. 
With this simple example the programmer has lost compile time safety as Go gives up once it encounters the use of interface{}. 
One might argue, the *id* function is barely used other than for demonstration purposes. 
So, how about a key concept of functional programming: functional composition. 
Functional composition allows you to combine a number of functions to form a new one. 
Hereby the result of one function is passed as the argument to the next one.

[source, go]
----
//just for improved readability
type any interface{}
type function func(any) any

func compose(g, f function) function {
	return func(x any) any {
		return g(f(x))
	}
}

func pow2(x any) any { //needs this type declaration, otherwise it cannot be passed to compose
	return x.(int) * x.(int)
}

func sqrt(x any) any { //needs this type declaration, otherwise it cannot be passed to compose
	return math.Sqrt(float64(x.(int)))
}

same := compose(sqrt, pow2) //first copute pow2, then sqrt with result of pow2
same(12392)     //--> 12392
----

Here the problem becomes obvious. 
For being polymorph the compose function takes two functions that take *interface{}* as parameter. 
As a consequence every function that strives to be composable has to adhere to the type signature with *interface{}*. 
This leads to the loss of compile time safety a static type system provides. 
Furthermore readibility suffers as the empty interface{} by itself does not allow any reasoning about used types, which is fundamentally different to parametric polymorphism.
In fact, when writing Go this way the type system has become more of a burden than of actual use. +

Elixir is using different concepts than Go. 
It is a dynamically typed language, which means all types of a program are inferred by the runtime. 
Although it is dynamically typed, Elixir supports strict type checks for operators. 

.main.exs
[source, elixir]
----
hype = "Elixir is awesome"
awesomeness = 42
hype + awesomeness # This is an error
----

In this example two variables were defined, one of type string and other of type int. 
The *+* operator requires both sides to be of type int. 
This compiles with a warning, but will result in the following error at runtime: 

----
warning: this expression will fail with ArithmeticError
  main.exs:3

** (ArithmeticError) bad argument in arithmetic expression
    main.exs:3: (file)
    (elixir) lib/code.ex:767: Code.require_file/2
----

So far so good. Let's head to our Id function. 

[source, elixir]
----
id = fn a -> a end
id.("some") #--> "some"
----

Writing this function is a breeze in Elixir compared to Go. 
It supports all types and works without casting. 
Next define the compose function: 

[source, elixir]
----
compose = fn(g, f) -> 
            fn(arg) -> g.(f.(arg)) end 
          end
pow2 = fn(x) -> x * x end
sqrt = fn(x) -> :math.sqrt(x) end #uses the erlang math library

same = compose.(sqrt, pow2)
same.(10) #--> 10.0
----

This just looks like an improved version of the Go code. 
Without the types and braces the Elixir code gives a less cluttered look to the eye. 
Another big bonus is the absence of casting, which again improves readability and allows for better function reuse. 
Last, the signature of the composed functions stays natural, whereas the Go version forced functions to be defined with *interface{}*. 
It is fair to say, that elixir allows the more elegant functional code due to more concise syntax and the absence of types. 
However, as a consequence there is no compile time safety and hence nothing preventing you from composing non sense. 
Same holds true for Erlang and the underlying Beam VM. 
This design decision led to criticism and requests for a strict type system. 
Apparently there was an attempt to integrate this request without breaking the erlang ecosystem, which failed for several reasons.  
As a result the request was solved in a different way.
Erlang now provides a tool called "Dialyzer", which performs static type analysis. 
Elixir uses the same tool to solve the exact same problem. 
A programmer can optionally provide type specifications for functions. 
Dialyzer will then analyse whether the functions is called with wrong arguments in the code. 
With this technique Elixir tries to combine the best of the dynamically and strictly typed worlds. 
You get the feel of a dynamically typed language plus most of the security a strict type system provides. 


== Purity

== Immutability
Immutability is a well known principle in programming in general, but especially popular in functional programming languages. 
An object is called immutable if it guarantees there is no possibility to modify its values. 
Hence a reference to that object guarantees to always point to the same value. 
Immutability offers some welcome adavantages, such as thread safety and improved reasoning about written code. 
Before we dive into Elixir and Go a few terms need to be defined.

A *Reassignment* occurs if a variable's reference can be rebound to point to a different object. 
This is not a mutation, as the previously pointed to object is left unchanged. 
Few languages are driven by strict non-assignability, which prohibits the reassignment of variables. 
Instead most languages allow references to change. 
More important is whether the immutability guarantees for an object are *deep* or *shallow*. 
For *deep* immutability all object's fields must non reassignable and transitively-referred to objects have to be immutable as well. 
In contrast, *shallow* immutability forbids the reassignment of an object's fields but allows for transitively referred to objects to be mutated. 
From a clients perspective the deep immutablity guarantees are preferable. 

In Elixir all data guarantees deep immutability. 
In general this means whenever a structure shall be modified, a new object with the modified values is the result. 
Note that elixir internally handles this case differently depending on the type of updated object. 
For more details please head to the Elixir documentation. 
For the reassignment part: Elixir allows to bind a label to a value. 
I used label on purpose, as the usually used term variable tends to confuse. 
Attaching a label in Exilir actually means that the left hand side is interchangable with the right hand side of the statement. 
For mutable objects in other languages this is not true, thus the differentiation between variables and labels. 
Unlike Erlang those labels can be shadowed and even be rebinded, as shown below:   

[source, elixir]
----
a = "now"
x = a
a = "later" #rebinding a
# a is "later", x is "now"

shadow = fn b -> 
              a = "see you " #Here the outer a gets shadowed by the inner a. Outer a is inaccessible
              a <> b
          end 
shadow.(a) # --> "see you later"
# a is still "later"
----

Go by itself does barely make any guarantees at all. 
However it provides language features that enable immutability to some extent. 
Some Basic types of Go are immutable, such as numbers, booleans and strings (and a bunch more), but the standard container types such as maps or arrays/slices are mutable. 
Let us have a look at the easiest language feature for immutability: const. 

[source, go]
----
const Pi = 3.14  //This can never change
----

Meant for defining constants, *const* is a keyword of the Go language. 
This can only be used in conjunction with the types character, string, boolean, or numeric values. 
Obviously this is not sufficient, hence have a look at other options. 
Go features pointers, which gives the programmer control about how values are passed to functions. 
With this at hand, it is possible to build functions where parameters are passed call by value.
Hereby the function receives an actual copy of the object. 
This effectively makes it impossible for the function to mutate the state of the object referenced from the outer scope. 
In contrast using a pointer, and therefore call by reference, the function can mutate the state of the object having an effect in the outer scope. 
Using this technique allows to design immutable data types, as the following example illustrates: 

[source, go]
----
package rational 

//represents a rational number with numberator/denominator
type Rational struct {
	numerator   int  //starts with a lowercase letter, thus cannot be accessed from outside this package
	denominator int
}

func NewRational(numerator int, denominator int) Rational {
	//creates a new Rational number 
}

//Call by value, cannot mutate object
func (x Rational) Multiply(y Rational) Rational {
	return NewRational(x.numerator*y.numerator, x.denominator*y.denominator) //Returns a NEW Rational object
}  

func (x Rational) GetNumerator() int {
  return x.numerator
}
----

The above pattern shows how to implement immutable data structures in Go. 
All of its methods are read only and never mutating. 
This be can ensured by using call by value and in case of modification always creating new objects. 
Unfortunately this pattern cannot guarantee immutability entirely, as the struct fields may be used from within the same package. 
So, the package developer has to make sure not to mutate the object as Go does not allow any further restrictions. 
The last option Go offers is to create manual copies of the objects. 
Unfortunately this obfuscates the code for the sake of immutability and adds runtime overhead. 
To sum up, Go was not designed with immutability as paramount and exactly feels that way. 
It does not help the developer to make any assumptions nor guarantees. 
Based on that, almost no library was written with immutability as a major concern. 
However, it follows, a libary's client can only be pessimistic and assume mutability. 
So even if your part of the program is strictly immutable, when calling into a library you lose that safety. 


== Functional Programmer's Toolbox

== Standard Library

== Performance

Obviously different implementations of programming languages behave differently regarding performance. 
The same often holds true when implementing a feature in different paradigms within one language. 
Functional programming usually avoids mutation of state and thus encourages the use of recursion. 
However this can result in a serious performance difference compared to imperative programming, depending on how the compiler/runtime optimizes the code. 
Thus this chapter will not compare Elixir and Go with each other but rather how the use of recursion vs imperative features affects a programs runtime. 

Elixir does not allow to mutate state and as such can not support any iterative control flow structures such as the *for* or *while* loops. 
Thus a programmer has to rely on recursion to get the job done. 
This means, a function is called recursively until a condition is reached, that stops the continuation.
A classic example is a function, that computes the nth-fibonacci number. 
Where a Fibonacci Number is defined as:  

stem:[f_n = f_(n-1) + f_(n-2) forall n>2]

with the starting values:
stem:[f_0 = 0]
stem:[f_1 = 1]

With the use of pattern matching a corresponding function in Elixir could look like the following:

[source, elixir]
----
def fibonacci(n) when n < 0, do: raise "Bad Boy! Fibonacci is defined only for n >= 0"
def fibonacci(0), do: 0
def fibonacci(1), do: 1
def fibonacci(n), do: fibonacci(n-1) + fibonacci(n-2)
----

The given implementation uses recursion for computing the fibonacci number, whereas computing one fibonacci number will always yield two function calls.
Since a fibonacci number depends on its two predecessors, a cascade of function calls is necessary for computing a fibonacci number with a bigger n. 
Running this function naively without any optimizations applied is surely not optimal. 
The reason behind this observation lies in the cascade of function calls. 
Each function call results in a new stack frame, which is alot of overhead for actually just passing around the called function's return value. 
A common applied optimization for functional languages is the so called tail call optimization. 
This optimization can be applied when the last executed statement of a function is a function call. 
A recursive function that fits the mentioned requirements is called tail recursive. 
When the optimization is applied, the creation of new stack frames is avoided and the computation can run with constant stack space. 
Ultimately this results in a huge performance benefit. 
Elixir does provide this type of optimization, so how about using it?
When looking at our naive fibonacci implementation, the last executed statement is actually an addition. 
So we need to change the algorithm how the fibonacci number is computed to be a tail recursive one.  

[source, elixir]
----
def fibonacci(n) when n < 0, do: raise "Bad Boy! Fibonacci is defined only for n >= 0"
def fibonacci(n), do: pfib(n, 1, 0)  #allows for a simple interface with arity 1, but dispatches the tailrecursion to a private implementation
defp pfib(0, _, result), do: result  #defp defines a private (not visible for the outside world) function
defp pfib(n, next, result), do: pfib(n-1, next+result, next) #Hooray! This is tail recursive!
----

When measuring execution times a huge difference between the two versions can be observed. 
I will just measure very roughly, as my goal is not to show absolute numbers, but the relative difference. 
The used method does not respect the times our program spent in kernel or user mode. 
But i suppose, when executing it a number of times it still has its relevance (in the end you might just want to test it yourself!). 
I used the following: 

[source, elixir]
----
def timeIt(n) do
    start = :os.system_time(:seconds)
    fibonacciNumber = fibonacci(n)
    finish = :os.system_time(:seconds)
    timeTaken = finish - start
    IO.puts "#{n}-th Fibonacci number is: #{fibonacciNumber}. Computation finished in #{timeTaken} seconds!"
  end
----

The version with the naive implementation resulted in: 
----
45-th Fibonacci number is: 1134903170. Computation finished in 20 seconds!
----

The optimized version:
----
45-th Fibonacci number is: 1134903170. Computation finished in 0 seconds!
#No this is not a mistake - it was just that much faster!
----

As we can see, the difference is enormous. 
Apparently, it is so significant, the optimized version could easily compute the 300000th fibonacci number on my machine within a second! 
To sum up, even though elixir as a functional language relies on recursion only, it can be incredibly fast and efficient, when used correctly. 

Let us now have a look at how Golang handles things. 
Go, unlike Elixir, supports both iterative structures and recursion. 
Though, as of now Golang does not support tail call optimization. 
Simply put, for computationally intensive tasks recursion should be avoided. 
Thus an efficient function that computes fibonacci numbers in Go must be iterative. 
The performance difference between the recursive and iterative approach is comparable to the optimized and unoptimized versions used with elixir. 
Based on this observation it can be concluded, that it is not reasonable to use the purely recursive approach, often seen in functional programming, in Go. 

== Conclusion

== Sources & Further Readings

Immutability: https://homes.cs.washington.edu/~mernst/pubs/immutability-aliasing-2013-lncs7850.pdf